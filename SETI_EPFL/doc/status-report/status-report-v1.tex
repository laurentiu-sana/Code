\documentclass{article}

\usepackage[utf8x]{inputenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{caption}
  
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{language=Java,
  tabsize=3,
  frame=lines,
  keywordstyle=\color{blue},
  commentstyle=\color{darkgreen},
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  breaklines=true,
  showstringspaces=false,
  basicstyle=\footnotesize,
  emph={label}
}

\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{9.0in}
\setlength{\textwidth}{6.0in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\parindent}{0.15in}
\setlength{\parskip}{0.05in}

\begin{document}

students: Octavian Ganea, Cristian Tălău, Laurențiu Dascălu

\textbf{Problem statement}

Our idea is to build a system to run SETI@HOME like projects which execute 
multiple tasks on the machines of ordinary Internet users that are idling 
on websites. Our goal is to split high resource consuming applications into 
tasks and send them to run as JavaScript code on people's local machines. 
This code will be compiled from Java code allowing developers to use their 
favorite language to write distributed applications.

In the final version, we will expect that the programmer uploads three Java 
classes (\emph{map worker}, \emph{reduce worker}, \emph{input generator}) and 
an input file. The classes are dynamically plugged into our system, and it
starts executing his/her code as any MapReduce framework (e.g.
Hadoop). %\footnote{http://hadoop.apache.org/}). 
%Initially, the server compiles the
%workers from Java to JavaScript. When a voluntary user (i.e. the JS running in 
%her browser) requests a task for the first time (e.g. map/reduce), we give to 
%execution the compiled map/reduce worker and some input; for a map task, the 
%server sends data generated by the \emph{input generator} and for a reduce task, 
%it sends data resulted from previous map tasks. 

% nu inteleg cand se intampla otherwise :) 
%Otherwise, we transfer just the data itself for the task, as the
%map/reduce worker JavaScript code is already loaded in the user's browser.
We have designed the interfaces that are to be used by the user. 

\textbf{Server-side interface}

%Interfata asta e interna la noi.. useru nu are treaba cu ea

%interface ServerServiceAsync <K1, V1, K2, V2>
%  void getTask(String projectName, AsyncCallback<Task<K1, V1, K2, V2>> callback)
%  void putMapResult(SVector<Pair<K2, V2>> result, int taskId,
%    AsyncCallback<Void> callback);
%  void putReduceResult(SVector<V2> result, int taskId,
%    AsyncCallback<Void> callback);

The server uses one \emph{IInputGenerator} per project that run on that server.

\begin{lstlisting}
interface IInputGenerator <K extends IsSerializable, V extends IsSerializable>
  boolean hasNextTask();
  Task<K, V> nextTask();
\end{lstlisting}

\textbf{Client-side interface}

On the client-side, we provide a collection classes that the programmer will
customize. We provide a \textit{JobConf} implementation that is responsible for
the \textit{map} and \textit{reduce} workers instantiation, for the
communication with the server (e.g. download tasks, upload results). From the
client-side perspective, the programmer has just to define his/her map workers.

\begin{lstlisting}
interface IOutputCollector<T>
  void emit(T data);

interface IMapWorker<K1, V1, K2, V2>
  void map(K1 key, V1 value, IOutputCollector<Pair<K2, V2>> output);

interface IReduceWorker<K, V>
  void reduce(K key, SVector<V> value, IOutputCollector<V> output);
\end{lstlisting}


\textbf{Shared structures}

The clients and the server share the \textit{map} and \textit{reduce} tasks
structures, and other common types (e.g. serializable String, Integer, Boolean,
Void). 
% Se vede mai jos ca asa le-am declarat
%We define the \textit{MapTask} as a vector of key-value pairs and the
%\textit{ReduceTask} as a pair of a key and an array of values corresponding to
%that key.

\begin{lstlisting}
class MapTask<K, V> extends Vector<Pair<K, V>> implements Task<K, V>
class ReduceTask<K, V> extends Pair<K, Vector<V>> implements Task<K, V>
interface Task<K, V>
\end{lstlisting}

\textbf{Mandelbrot example}

Currently, we created the system structure that statically uses some
implementation a map worker and a reduce worker that compute the Mandelbrot 
fractal of given size. The \textit{MandelbropMapWorker} computes a part of
the Mandelbrot fractal image and the \textit{MandelBrotReduceWorker} combines 
all these lines in a final image. 

Interestingly, we found that computing a 256x256 Mandelbrot fractal using
Java takes about 17 seconds, while the generated JavaScript code from that Java
code takes less than 7 seconds. We believe that this is due to the poor
performance of our JVM.

%optimizations performed only by the JavaScript VM but not by our JVM (e.g
%JIT) %\footnote{\url{http://en.wikipedia.org/wiki/Just-in-time_compilation}}).

The \emph{custom} classes are separated from the generic part of the system, 
so it should be easily generalized to support dynamically provided 
\emph{mappers} and \emph{reducers}. After this we will look at some features
like: fault-tolerance, load balancing, security, performance issues.

We found out that combining images on the client is unfortunate, because the 
data transfer is more expensive than \emph{reducing} it (store multiple 
matrices in a single matrix). Thus, we figured out that the programmer has to 
specify if a reduce task can be executed on the server directly.

%(e.g. transfer it to a client) or it should be executed on server. If we execute
%a task on server, than it should not affect the system's responsiveness (e.g.
%other projects should continue their normal execution unaffected).

% For details, please check our SVN\footnote{Subversion --
% \url{http://subversion.apache.org/}} repository at
% \url{https://svn.epfl.ch/svn/seti-at-epfl/}.

\end{document}
